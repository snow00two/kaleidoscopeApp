/* kaleidoscope  
* plane symmetry groups generated by reflections 
* 2025/04/24 version 0.19, Yukio Otsu (Kyushu University), 
* \href{https://creativecommons.org/licenses/by-nc-nd/4.0/}{\ccbyncsa}
*/
const WIDTH_CANVAS = 720 * 3 / 2; //=1080　similar to infty 
const HEIGHT_CANVAS = 405 * 3 / 2; //=607.5 similar to infty
const CENTER_X = WIDTH_CANVAS / 2;
const CENTER_Y = HEIGHT_CANVAS / 2;
const BACK_COLOR = 255;//
const FRONT_COLOR_0 = [255,  0, 0];
const FRONT_COLOR_1 = [220, 50, 0];
const FRONT_COLOR_2 = [185, 100, 0];
const FRONT_COLOR_3 = [170, 150, 120];
const FRONT_COLOR_4 = [180, 180, 160];
const FRONT_COLOR_5 = [150, 170, 120];
const FRONT_COLOR_6 = [100, 185, 0];
const FRONT_COLOR_7 = [50, 220, 0];
const FRONT_COLOR_8 = [0, 255, 80];
const COLOR_LIST = [FRONT_COLOR_0, FRONT_COLOR_1, FRONT_COLOR_2,FRONT_COLOR_3, 
    FRONT_COLOR_4, FRONT_COLOR_5, FRONT_COLOR_6, FRONT_COLOR_7, FRONT_COLOR_8];
const GROUP_LIST =['Pmm', 'P3mm', 'P4mm', 'P6mm'];
const FIGURE_LIST = ['bounceBall', 'bounceBall1', 'floppingTriangle1'];
const BASE_SEGMENT = 150;//150
const SPEED = 0.5;
const RADIUS1 = 10;
const FLOP_PRIOD = 150; //200
const SELECT_PRIOD = 25 * FLOP_PRIOD;

let varScale;
let varSegment;
let varHeight;
let varSpeed;
let varRadius;
let angleB; //angle of direction of bounce ball
let angleBP; //angle of direction of bounce ball Prime
let diamB1;
let diamB2;
let xX;
let xY;
let uX;
let uY;
let xPX;
let xPY;
let uPX;
let uPY;

let selectGroup;
let lineSwitch;
let lineState;
let setScale;
let selectFigure;
let stopSwitch;
let groupState;
let presentGroup;
let figureState;
let presentFigure;
let colorV0 ;
let colorV1 ;
let colorV2 ;
let colorV3 ;
let colorV4 ;
let colorV5 ;
let colorV6 ;
let colorV7 ;
let colorV8 ;
let n = 0; // fast clock parameter 
let m = 0; // slow clock parameter 
let k = 0; // parameter for refreshing figure in flopping triangles
let seqTriName;
let seqTriNameL;
let seqTri; //keep the name of sequence of triangles
let seqTriL;
let triSL; //keep the name of triangles
let triV0;
let triV1;
let triV2;
let triV3;
let triV4;
let triV5;
let triV6;
let triV7;
let triV8;
let triS0L;
let triS1L;
let triS2L;
let triS3L;
let triS4L;
let triS5L;
let triS6L;
let triS7L;
let triS8L;
let triS9L;
let triS10L;
let triS11L;
let triS12L;
let triS13L;
let triS14L;
let triS15L;

function setup() {
    selectGroup = createSelect();
    selectGroup.option('auto', 'auto');
    selectGroup.option('Pmm', 'Pmm');
    selectGroup.option('P3mm', 'P3mm');
    selectGroup.option('P4mm', 'P4mm');
    selectGroup.option('P6mm', 'P6mm');
    selectGroup.selected('auto');
    selectGroup.position(14, 20);
    selectGroup.changed(resetBackground);

    selectFigure = createSelect();
    selectFigure.option('auto', 'auto')
    selectFigure.option('bouncing balls', 'bounceBall');
    selectFigure.option('bouncing balls 1', 'bounceBall1');
    // selectFigure.option('still triangles', 'stillTriangle');
    // selectFigure.option('flopping triangles', 'floppingTriangle');//
    selectFigure.option('flopping triangles', 'floppingTriangle1');//
    //selectFigure.option('flopping triangles 2', 'floppingTriangle2');//
    selectFigure.selected('auto');
    selectFigure.position(95, 20);
    selectFigure.changed(resetBackground);

    setScale = createSelect();//createSlider(1/2, 2, 1, 1) ;
    setScale.option('0.5', '0.5');
    setScale.option('1', '1');
    setScale.option('2', '2');
    setScale.selected('1');
    setScale.position(270, 20);
    setScale.changed(resetBackground);

    lineSwitch = createSelect();
    lineSwitch.option('line on', 'lineOn');
    lineSwitch.option('line off', 'lineOff');
    lineSwitch.selected('lineOn');
    lineSwitch.position(325, 20);

    stopSwitch = createRadio();
    stopSwitch.option('ongoing');
    stopSwitch.option('stopping');
    stopSwitch.selected('ongoing');
    stopSwitch.position(405, 20);

    //frameRate(0.5);//parameter for test 
    groupState = selectGroup.value();
    if (groupState === 'auto') {
        presentGroup = random(GROUP_LIST); //presentGroup is a global varialble
    } else {
        presentGroup = groupState;
    }
    figureState = selectFigure.value();
    if (figureState === 'auto') {
        presentFigure = random(FIGURE_LIST); //presentGroup is a global varialble
    } else {
        presentFigure = figureState;
    }
    [colorV0, colorV1, colorV2, colorV3, colorV4, colorV5, colorV6,
        colorV7, colorV8] = colorSet(presentGroup);

    varScale = setScale.value();
    varSegment = BASE_SEGMENT * varScale;
    varHeight = sqrt(3) * varSegment / 2;
    varSpeed = SPEED * varScale;
    varRadius = RADIUS1 * varScale;

    // angleB = random(0, 2 * PI);
    // angleBP = random(0, 2 * PI);
    // uX = cos(angleB);
    // uY = sin(angleB);
    // uPX = cos(angleBP);
    // uPY = sin(angleBP);
    // xX = groupData(presentGroup, presentFigure, 'x0X');
    // xY = groupData(presentGroup, presentFigure, 'x0Y');
    // xPX = groupData(presentGroup, presentFigure, 'xP0X');
    // xPY = groupData(presentGroup, presentFigure, 'xP0Y');

    createCanvas(WIDTH_CANVAS, HEIGHT_CANVAS);
    background(BACK_COLOR);   
}

function draw() {
    lineState = lineSwitch.value();
    stopState = stopSwitch.value();

    if (n % SELECT_PRIOD === 0 && (groupState === 'auto'||figureState === 'auto') ){
        k = 0;
        m = 0;
        if (groupState === 'auto'){
            presentGroup = random(GROUP_LIST); //presentGroup is a global varialble
        } else {
            presentGroup = groupState;
        }
        if (figureState === 'auto'){
            presentFigure = random(FIGURE_LIST); //presentGroup is a global varialble
        } else {
            presentFigure  = figureState;
        }
        [colorV0, colorV1, colorV2,colorV3, colorV4, colorV5, colorV6,
            colorV7, colorV8] = colorSet(presentGroup);

        xX = groupData(presentGroup, presentFigure, 'x0X');
        xY = groupData(presentGroup, presentFigure, 'x0Y');
        xPX = groupData(presentGroup, presentFigure, 'xP0X');
        xPY = groupData(presentGroup, presentFigure, 'xP0Y');
        angleB = random(0, 2 * PI);
        angleBP = random(0, 2 * PI);
        uX = cos(angleB);
        uY = sin(angleB);
        uPX = cos(angleBP);
        uPY = sin(angleBP);
    } else {
        k++;
    }
    if (presentGroup === 'Pm') {
        translate(CENTER_X, -HEIGHT_CANVAS / 6);//the center of scaling
    } else {
        translate(CENTER_X, CENTER_Y);//the center of scaling
    }
    let num = 4;
    let radB1 = groupData(presentGroup, presentFigure, 'radB1');
    let radB2 = groupData(presentGroup, presentFigure, 'radB2');

    background(BACK_COLOR);
    if (presentFigure === 'bounceBall') {
        [xX, xY, uX, uY] = trajectoryBB(stopState, radB1, presentGroup, presentFigure, num, xX, xY, uX, uY);
        num = 2;
        generatLattice(lineState, presentGroup, presentFigure, num, xX, xY);
    } else if (presentFigure === 'bounceBall1') {
        num = 8;
        [xX, xY, uX, uY, xPX, xPY, uPX, uPY] = trajectoryBB2(stopState, radB2, presentGroup, presentFigure, num, xX, xY, uX, uY, xPX, xPY, uPX, uPY);
        num = 4;
        generatLattice(lineState, presentGroup, presentFigure, num, xX, xY, xPX, xPY);
    } else if (presentFigure === 'stillTriangle') {
        num = 2;
        generatLattice(lineState, presentGroup, presentFigure, num, xX, xY);
    } else if (presentFigure === 'floppingTriangle'||presentFigure === 'floppingTriangle1') {
        num = 3;//num 2025/04/09???
        let triS0;
        let triS1;
        let triS2;
        let triS3;
        let triS4;
        let triS5;
        let triS6;
        let triS7;
        let triS8;
        let triS9;
        let triS10;
        let triS11;
        let triS12;
        let triS13;
        let triS14;
        let triS15;
        // let triS16;
        
        let seqTriList0 = [['seqTri4L', 'seqTri4'], ['seqTri5L', 'seqTri5'],
            ['seqTri6L', 'seqTri6'],['seqTri7L', 'seqTri7']];//
        let seqTriList00 = [['seqTri0L', 'seqTri0'], ['seqTri1L', 'seqTri1'],
            ['seqTri2L', 'seqTri2'], ['seqTri3L', 'seqTri3']];
        //let seqTriList10 = [['seqTri10L', 'seqTri10'], ['seqTri11L', 'seqTri11'], ['seqTri12L', 'seqTri12'], ['seqTri13L', 'seqTri13']];
        let seqTriList20 = [['seqTri20L', 'seqTri20'], ['seqTri21L', 'seqTri21'],
            ['seqTri22L', 'seqTri22'], ['seqTri23L', 'seqTri23']];

        if (m === 0) {
            if (presentGroup === 'P3mm' ) {
                [seqTriNameL, seqTriName] = random(seqTriList0);
            } else if (presentGroup === 'P6mm'){
                [seqTriNameL, seqTriName] = random(seqTriList00);
            } else if (presentGroup === 'P4mm' || presentGroup === 'Pmm' ) {
                [seqTriNameL, seqTriName] = random(seqTriList20);
            }  else  {
                ;
            }
            seqTriL = groupData(presentGroup, presentFigure, seqTriNameL);
        }

        if (seqTriL === 6) {//values of 'seqTri*L' : 6, 8, 12, 16
            seqTri = [triS0L, triS0, triS1L, triS1, triS2L, triS2, triS3L, triS3,
                triS4L, triS4, triS5L, triS5] = groupData(presentGroup, presentFigure, seqTriName);
        } else if (seqTriL === 8) {
            seqTri = [triS0L, triS0, triS1L, triS1, triS2L, triS2, triS3L, triS3,
                triS4L, triS4, triS5L, triS5, triS6L, triS6, triS7L, triS7] = groupData(presentGroup, presentFigure, seqTriName);
        } else if (seqTriL === 12) {
            seqTri = [triS0L, triS0, triS1L, triS1, triS2L, triS2, triS3L, triS3,
                triS4L, triS4, triS5L, triS5, triS6L, triS6, triS7L, triS7, triS8L, triS8,
                triS9L, triS9, triS10L, triS10, triS11L, triS11] = groupData(presentGroup, presentFigure, seqTriName);
        } else if (seqTriL === 16) {
            seqTri = [triS0L, triS0, triS1L, triS1, triS2L,triS2, triS3L, triS3,
                triS4L, triS4, triS5L,triS5, triS6L, triS6, triS7L, triS7, triS8L,
                triS8, triS9L, triS9, triS10L, triS10, triS11L, triS11, triS12L,
                triS12, triS13L, triS13, triS14L,triS14, triS15L, triS15] = groupData(presentGroup, presentFigure, seqTriName);
        }
        
        if (m < seqTriL) {
            if (n % FLOP_PRIOD === 0) {
                triSL = seqTri[2*m];
                if (triSL === 1){
                    [triV0] = seqTri[2*m + 1];
                } else if (triSL === 2){
                    [triV0, triV1] = seqTri[2*m + 1];
                } else if (triSL === 3){
                    [triV0, triV1, triV2] = seqTri[2*m + 1];
                } else if (triSL === 4){
                    [triV0, triV1, triV2, triV3] = seqTri[2*m + 1];
                } else if (triSL === 5){
                    [triV0, triV1, triV2, triV3, triV4] = seqTri[2*m + 1];
                } else if (triSL === 6){
                    [triV0, triV1, triV2, triV3, triV4, triV5] = seqTri[2*m + 1];
                } else if (triSL === 7){
                    [triV0, triV1, triV2, triV3, triV4, triV5, triV6] = seqTri[2*m + 1];
                } else if (triSL === 8){
                    [triV0, triV1, triV2, triV3, triV4, triV5, triV6, triV7] = seqTri[2*m + 1];
                } else if (triSL === 9){
                    [triV0, triV1, triV2, triV3, triV4, triV5, triV6, triV7, triV8] = seqTri[2*m + 1];
                }
                m++;
            }
        } else {
            m = 0;
        }
        generatLattice(lineState, presentGroup, presentFigure, triSL, triV0, triV1, triV2, triV3, triV4, triV5, triV6, triV7, triV8);
    }

    if (stopState === 'ongoing') {
        n++; //update n
    } else {
        n = n; //stop n
    }
}

function groupData(groupName, figureName, dataName) {
    /* the database of the infomation of space groups */
    let varSmall = 0.0013;//parameter to change the move of balls
    let varSmall2 = 0.02; //0.0013 : parameter to strengthen the speed of balls that speed down
    let squareFlag = false;
    let diamB1 = varRadius;
    let diamB2 = varRadius;
    let x0X ;
    let x0Y ;
    let xP0X ;
    let xP0Y ;
    let pX;
    let pY;
    let qX;
    let qY;
    let rX;
    let rY;
    let sX; //when squareFlag=== true
    let sY; //when squareFlag=== true
    let pqNX; //variable using for normal vectors
    let pqNY;
    let qrNX;
    let qrNY;
    let rpNX;
    let rpNY;
    let rsNX;
    let rsNY;
    let spNX;
    let spNY;

    /* Dirichle domain */
    let denomiNator;
    let mirState;
    /* lattice generator */
    let firstDelimiter;
    let secondDelimiter;
    let basicVector0X;
    let basicVector0Y;
    let basicVector1X;
    let basicVector1Y;

    /*  data for the still triangles mode */
    let dP = varHeight / 15;
    let pPX;
    let pPY;
    let qPX;
    let qPY;
    let rPX;
    let pVX;//2025/04/19
    let pVY;
    let qVX;
    let qVY;
    let rVX;
    let rVY;
    let sVX;
    let sVY;

    /*  data for the flopping triangles mode */
    //let ｓX; // variable using for additional edges
    //let ｓY; 2025/04/07
    let tX; 
    let tY;
    let uX;
    let uY;
    let vX;
    let vY;
    let wX;
    let wY;
    let zX;
    let zY;
    let cX;
    let cY;
    let p0X;
    let p0Y;
    let q0X;
    let q0Y;
    let r0X;
    let r0Y;
    let p1X;
    let p1Y;
    let q1X;
    let q1Y;
    let r1X;
    let r1Y;
    let p2X;
    let p2Y;
    let q2X;
    let q2Y;
    let r2X;
    let r2Y;
    let p3X;
    let p3Y;
    let q3X;
    let q3Y;
    let r3X;
    let r3Y;
    let p4X;
    let p4Y;
    let q4X;
    let q4Y;
    let r4X;
    let r4Y;
    let p5X;
    let p5Y;
    let q5X;
    let q5Y;
    let r5X;
    let r5Y;
    let p6X;
    let p6Y;
    let q6X;
    let q6Y;
    let r6X;
    let r6Y;
    let p7X;
    let p7Y;
    let q7X;
    let q7Y;
    let r7X;
    let r7Y;
    let p8X;
    let p8Y;
    let q8X;
    let q8Y;
    let r8X;
    let r8Y;
    let trisL0 = 1;
    let trisL1 = 2;
    let trisL2 = 3;
    let trisL3 = 4;
    let trisL4 = 5;
    let trisL5 = 6;
    let trisL6 = 7;
    let trisL7 = 8;

    if (groupName === 'P3mm') {
        varSmall2 = 0.008;//2024/11/19
        radB1 = varRadius;
        radB2 = varRadius;
        pX = 0;
        pY = 0;
        qX = varSegment;
        qY = 0;
        rX = varSegment / 2;
        rY = varHeight;
        pqNX = cos(-PI / 2);
        pqNY = sin(-PI / 2);
        qrNX = cos(PI / 6); //1/6 + 1/2 =2/3
        qrNY = sin(PI / 6);
        rpNX = cos(5 * PI / 6);//1/6 + 2/3 = 5/6
        rpNY = sin(5 * PI / 6);
        denomiNator = 3;
        mirState = true;
        firstDelimiter = floor(WIDTH_CANVAS / varSegment);
        secondDelimiter = floor(WIDTH_CANVAS / varSegment);
        basicVector0X = 3 * varSegment / 2;
        basicVector0Y = varHeight;
        basicVector1X = 0;
        basicVector1Y = 2 * varHeight;
        pPX = sqrt(3) * dP;
        pPY = dP;
        qPX = varSegment - pPX;
        qPY = pPY;
        rPX = varSegment / 2;
        rPY = varHeight - 2 * dP;
        [pVX, pVY, qVX, qVY, rVX, rVY] = selectBasePoint(figureName, squareFlag, pX, pPX, pY, pPY, qX, qPX, qY, qPY, rX, rPX, rY, rPY);
        cX = (pVX + qVX + rVX) / 3;
        cY = (pVY + qVY + rVY) / 3;
        x0X = cX;
        x0Y = cY + radB2;
        xP0X = cX - radB2;
        xP0Y = cY - radB2 ;
        sX = (pVX + qVX )/ 2;
        sY = (pVY + qVY )/ 2;
        tX = (qVX + rVX )/ 2;
        tY = (qVY + rVY )/ 2;
        uX = (pVX + rVX )/ 2;
        uY = (pVY + rVY )/ 2;
        //data of tri0 
        p0X = pVX;
        p0Y = pVY;
        q0X = qVX;
        q0Y = qVY;
        r0X = cX;
        r0Y = cY;
        //data of tri1 
        p1X = qVX;
        p1Y = qVY;
        q1X = rVX;
        q1Y = rVY;
        r1X = cX;
        r1Y = cY;
        //data of tri2 
        p2X = rVX;
        p2Y = rVY;
        q2X = pVX;
        q2Y = pVY;
        r2X = cX;
        r2Y = cY;
        //data of tri3 
        p3X = pVX;
        p3Y = pVY;
        q3X = sX;
        q3Y = sY;
        r3X = cX;
        r3Y = cY;
        //data of tri4
        p4X = sX;
        p4Y = sY;
        q4X = qVX;
        q4Y = qVY;
        r4X = cX;
        r4Y = cY;
        //data of tri5 
        p5X = qVX;
        p5Y = qVY;
        q5X = tX;
        q5Y = tY;
        r5X = cX;
        r5Y = cY;
        //data of tri6
        p6X = tX;
        p6Y = tY;
        q6X = rVX;
        q6Y = rVY;
        r6X = cX;
        r6Y = cY;
        //data of tri7 
        p7X = rVX;
        p7Y = rVY;
        q7X = uX;
        q7Y = uY;
        r7X = cX;
        r7Y = cY;
        //data of tri8 
        p8X = uX;
        p8Y = uY;
        q8X = pVX;
        q8Y = pVY;
        r8X = cX;
        r8Y = cY;
    } else if (groupName === 'P4mm') {
        varSmall2 = 0.004;//2024/11/19
        radB1 = varRadius;
        radB2 = varRadius;
        pX = 0;
        pY = 0;
        qX = varHeight;
        qY = 0;
        rX = qX;
        rY = varHeight;
        pqNX = cos(-PI / 2);
        pqNY = sin(-PI / 2);
        qrNX = cos(0);
        qrNY = sin(0);
        rpNX = cos(3 * PI / 4);
        rpNY = sin(3 * PI / 4);
        denomiNator = 4;
        mirState = true;
        firstDelimiter = floor(WIDTH_CANVAS / varHeight);
        secondDelimiter = floor(WIDTH_CANVAS / varHeight);
        basicVector0X = 2 * varHeight;
        basicVector0Y = 0;
        basicVector1X = 0;
        basicVector1Y = 2 * varHeight;
        pPX = dP / tan(PI / 8);
        pPY = dP;
        qPX = qX - dP;
        qPY = dP;
        rPX = qPX;
        rPY = rY - dP / tan(PI / 8);
        [pVX, pVY, qVX, qVY, rVX, rVY] = selectBasePoint(figureName, squareFlag, pX, pPX, pY, pPY, qX, qPX, qY, qPY, rX, rPX, rY, rPY);
        cX = (pVX + rVX) / 2;
        cY = (pVY + rVY) / 2;
        x0X = (cX + qVX)/2 - dP;
        x0Y = (cY + qVY)/2 - dP;
        xP0X = (cX + qVX)/2 + dP;
        xP0Y = (cY + qVY)/2 + dP;
        zX = (pVX + cX) / 2;
        zY = (pVY + cY) / 2;
        tX = (pVX + qVX) / 2;
        tY = (pVY + qVY) / 2;
        uX = (qVX + cX) / 2;
        uY = (qVY + cY) / 2;
        vX = (qVX + rVX) / 2;
        vY = (qVY + rVY) / 2;
        wX = (rVX + cX) / 2;
        wY = (rVY + cY) / 2;
        p0X = pVX;
        p0Y = pVY;
        q0X = tX;
        q0Y = tY;
        r0X = zX;
        r0Y = zY;
        //data of tri1 //
        p1X = zX;
        p1Y = zY;
        q1X = tX;
        q1Y = tY;
        r1X = cX;
        r1Y = cY;
        //data of tri2 //
        p2X = tX;
        p2Y = tY;
        q2X = uX;
        q2Y = uY;
        r2X = cX;
        r2Y = cY;
        //data of tri3 //
        p3X = tX;
        p3Y = tY;
        q3X = qVX;
        q3Y = qVY;
        r3X = uX;
        r3Y = uY;
        //data of tri4 //
        p4X = qVX;
        p4Y = qVY;
        q4X = vX;
        q4Y = vY;
        r4X = uX;
        r4Y = uY;
        //data of tri5 //
        p5X = uX;
        p5Y = uY;
        q5X = vX;
        q5Y = vY;
        r5X = cX;
        r5Y = cY;
        //data of tri6 //
        p6X = cX;
        p6Y = cY;
        q6X = vX;
        q6Y = vY;
        r6X = wX;
        r6Y = wY;
        //data of tri7 //
        p7X = wX;
        p7Y = wY;
        q7X = vX;
        q7Y = vY;
        r7X = rVX;
        r7Y = rVY;
    } else if (groupName === 'P6mm') {
        radB1 = varRadius;
        radB2 = varRadius;
        pX = 0;
        pY = 0;
        qX = varHeight;
        qY = 0;
        rX = varHeight;
        rY = varSegment / 2;
        pqNX = cos(-PI / 2);
        pqNY = sin(-PI / 2);
        qrNX = cos(0);
        qrNY = sin(0);
        rpNX = cos(2 * PI / 3);
        rpNY = sin(2 * PI / 3);
        // qAngle = 2*PI/3 ;
        // qSign = -1 ;
        denomiNator = 6;
        mirState = true;
        firstDelimiter = floor(WIDTH_CANVAS / varSegment);
        secondDelimiter = floor(WIDTH_CANVAS / varSegment);
        basicVector0X = 2 * varHeight;
        basicVector0Y = 0;
        basicVector1X = varHeight;
        basicVector1Y = 3 * varSegment / 2;
        pPX = dP / tan(PI / 12);
        pPY = dP;
        qPX = varHeight - dP;
        qPY = dP;
        rPX = qPX;
        rPY = varHeight / sqrt(3) - dP / tan(PI / 6);
        [pVX, pVY, qVX, qVY, rVX, rVY] = selectBasePoint(figureName, squareFlag, pX, pPX, pY, pPY, qX, qPX, qY, qPY, rX, rPX, rY, rPY);
        cX = (pVX + qVX+ rVX)/3;
        cY = (pVY + qVY+ rVY)/3;
        tX = pVX / 3 + 2 * qVX / 3;
        tY = pVY / 3 + 2 * qVY / 3;
        uX = pVX / 2 + rVX / 2;
        uY = pVY / 2 + rVY / 2;
        x0X = 2 * tX/3 + rVX/3 + radB2;
        x0Y = 2 * tY/3 + rVY/3 + radB2;
        xP0X = 2 * tX/3 + rVX/3 - radB2 ;
        xP0Y = 2 * tY/3 + rVY/3 - radB2;
        //data of tri0
        p0X = pVX;
        p0Y = pVY;
        q0X = tX;
        q0Y = tY;
        r0X = uX;
        r0Y = uY;
        //data of tri1 
        p1X = tX;
        p1Y = tY;
        q1X = rVX;
        q1Y = rVY;
        r1X = uX;
        r1Y = uY;
        //data of tri2 
        p2X = tX;
        p2Y = tY;
        q2X = qVX;
        q2Y = qVY;
        r2X = rVX;
        r2Y = rVY;
    } else if (groupName === 'Pmm') {
        squareFlag = true;
        radB1 = varRadius;
        radB2 = varRadius;
        x0X = varSegment / 2 - radB1;
        x0Y = varSegment / 4 - radB1;
        xP0X = x0X + 2 * radB1;
        xP0Y = x0Y + 2 * radB1;
        pX = 0;
        pY = 0;
        qX = varSegment;
        qY = 0;
        rX = varSegment;
        rY = varSegment / 2;
        sX = 0;
        sY = varSegment / 2;
        pqNX = cos(-PI / 2);
        pqNY = sin(-PI / 2);
        qrNX = cos(0);
        qrNY = sin(0);
        rsNX = cos(PI / 2);
        rsNY = sin(PI / 2);
        spNX = cos(PI);
        spNY = sin(PI);
        denomiNator = 2;
        mirState = true;
        firstDelimiter = floor(WIDTH_CANVAS / varSegment);
        secondDelimiter = floor(2 * WIDTH_CANVAS / varSegment);
        basicVector0X = 2 * varSegment;
        basicVector0Y = 0;
        basicVector1X = 0;
        basicVector1Y = varSegment;
        pPX = dP;
        pPY = dP;
        qPX = qX - dP;
        qPY = pPY;
        rPX = qPX;
        rPY = rY - dP;
        sPX = pPX;
        sPY = rPY;
        [pVX, pVY, qVX, qVY, rVX, rVY, sVX, sVY] = selectBasePoint(figureName, squareFlag, pX, pPX, pY, pPY, qX, qPX, qY, qPY, rX, rPX, rY, rPY, sX, sPX, sY, sPY);
        //data of flopping Triangles
        tX = (pVX + qVX) / 2;
        tY = (pVY + qVY) / 2;
        uX = (qVX + rVX) / 2;
        uY = (qVY + rVY) / 2;
        vX = (rVX + sVX) / 2;
        vY = (rVY + sVY) / 2;
        wX = (sVX + pVX) / 2;
        wY = (sVY + pVY) / 2;
        cX = (pVX + rVX) / 2;
        cY = (pVY + rVY) / 2;
        //data of tri0 
        p0X = pVX;
        p0Y = pVY;
        q0X = tX;
        q0Y = tY;
        r0X = cX;
        r0Y = cY;
        //data of tri1 
        p1X = tX;
        p1Y = tY;
        q1X = qVX;
        q1Y = qVY;
        r1X = cX;
        r1Y = cY;
        //data of tri2 
        p2X = qVX;
        p2Y = qVY;
        q2X = uX;
        q2Y = uY;
        r2X = cX;
        r2Y = cY;
        //data of tri3 
        p3X = uX;
        p3Y = uY;
        q3X = rVX;
        q3Y = rVY;
        r3X = cX;
        r3Y = cY;
        //data of tri4
        p4X = rVX;
        p4Y = rVY;
        q4X = vX;
        q4Y = vY;
        r4X = cX;
        r4Y = cY;
        //data of tri5
        p5X = vX;
        p5Y = vY;
        q5X = sVX;
        q5Y = sVY;
        r5X = cX;
        r5Y = cY;
        //data of tri6 
        p6X = sVX;
        p6Y = sVY;
        q6X = wX;
        q6Y = wY;
        r6X = cX;
        r6Y = cY;
        //data of tri7 
        p7X = wX;
        p7Y = wY;
        q7X = pVX;
        q7Y = pVY;
        r7X = cX;
        r7Y = cY;
    }

    if (dataName === 'varSmall') {
        return varSmall;
    } else if (dataName === 'varSmall2') {
        return varSmall2;
    } else if (dataName === 'squareFlag') {
        return squareFlag;
    } else if (dataName === 'x0X') {
        return x0X;
    } else if (dataName === 'x0Y') {
        return x0Y;
    } else if (dataName === 'xP0X') {
        return xP0X;
    } else if (dataName === 'xP0Y') {
        return xP0Y;
    } else if (dataName === 'pX') {
        return pX;
    } else if (dataName === 'pY') {
        return pY;
    } else if (dataName === 'qX') {
        return qX;
    } else if (dataName === 'qY') {
        return qY;
    } else if (dataName === 'rX') {
        return rX;
    } else if (dataName === 'rY') {
        return rY;
    } else if (dataName === 'sX') {
        return sX;
    } else if (dataName === 'sY') {
        return sY;
    } else if (dataName === 'pqNX') {//2024/09/18
        return pqNX;
    } else if (dataName === 'pqNY') {//2024/09/18
        return pqNY;
    } else if (dataName === 'qrNX') {//2024/09/18
        return qrNX;
    } else if (dataName === 'qrNY') {//2024/09/18
        return qrNY;
    } else if (dataName === 'rpNX') {//2024/09/18
        return rpNX;
    } else if (dataName === 'rpNY') {//2024/09/18
        return rpNY;
    } else if (dataName === 'rsNX') {//2024/09/18
        return rsNX;
    } else if (dataName === 'rsNY') {//2024/09/18
        return rsNY;
    } else if (dataName === 'spNX') {//2024/09/18
        return spNX;
    } else if (dataName === 'spNY') {//2024/09/18
        return spNY;
    } else if (dataName === 'denomiNator') {
        return denomiNator;
    } else if (dataName === 'mirState') {
        return mirState;
    } else if (dataName === 'firstDelimiter') {
        return firstDelimiter;
    } else if (dataName === 'secondDelimiter') {
        return secondDelimiter;
    } else if (dataName === 'basicVector0X') {
        return basicVector0X;
    } else if (dataName === 'basicVector0Y') {
        return basicVector0Y;
    } else if (dataName === 'basicVector1X') {
        return basicVector1X;
    } else if (dataName === 'basicVector1Y') {
        return basicVector1Y;
    } else if (dataName === 'pPX') {
        return pPX;
    } else if (dataName === 'pPY') {
        return pPY;
    } else if (dataName === 'qPX') {
        return qPX;
    } else if (dataName === 'qPY') {
        return qPY;
    } else if (dataName === 'rPX') {
        return rPX;
    } else if (dataName === 'rPY') {
        return rPY;
    } else if (dataName === 'radB1') {
        return radB1;
    } else if (dataName === 'radB2') {
        return radB2;
    } else if (dataName === 'tri0') {
        return [p0X, p0Y, q0X, q0Y, r0X, r0Y];
    } else if (dataName === 'tri1') {
        return [p1X, p1Y, q1X, q1Y, r1X, r1Y];
    } else if (dataName === 'tri2') {
        return [p2X, p2Y, q2X, q2Y, r2X, r2Y];
    } else if (dataName === 'tri3') {
        return [p3X, p3Y, q3X, q3Y, r3X, r3Y];
    } else if (dataName === 'tri4') {
        return [p4X, p4Y, q4X, q4Y, r4X, r4Y];
    } else if (dataName === 'tri5') {
        return [p5X, p5Y, q5X, q5Y, r5X, r5Y];
    } else if (dataName === 'tri6') {
        return [p6X, p6Y, q6X, q6Y, r6X, r6Y];
    } else if (dataName === 'tri7') {
        return [p7X, p7Y, q7X, q7Y, r7X, r7Y];
    } else if (dataName === 'tri8') {
        return [p8X, p8Y, q8X, q8Y, r8X, r8Y];
    } else if (dataName === 'seqTri0') {//'P6mm'
        return [trisL0, ['empty'],trisL0,['tri2'], trisL1, ['tri1','tri2'],
            trisL2, ['tri0','tri1', 'tri2'], trisL1, ['tri0','tri1'], trisL0, ['tri0']];
    } else if (dataName === 'seqTri0L') {
        return 6;//values of 'seqTri*L' : 6, 8, 12, 16
    } else if (dataName === 'seqTri1') {
        return [trisL0, ['empty'], trisL0,['tri2'], trisL1, ['tri1','tri2'],
            trisL2, ['tri0','tri1', 'tri2'], trisL1, ['tri1','tri2'], trisL0, ['tri2']];
    } else if (dataName === 'seqTri1L') {
        return 6;
    } else if (dataName === 'seqTri2') {
        return [trisL0, ['empty'],trisL0, ['tri0'],  trisL1, ['tri0','tri1'],
            trisL2, ['tri0','tri1', 'tri2'], trisL1, ['tri1','tri2'], trisL0, ['tri2']];
    } else if (dataName === 'seqTri2L') {
        return 6;
    } else if (dataName === 'seqTri3') {
        return [trisL0, ['empty'],trisL0, ['tri0'],  trisL1, ['tri0','tri1'],
            trisL2, ['tri0','tri1', 'tri2'], trisL1, ['tri0','tri1'], trisL0,
                ['tri0']];
    } else if (dataName === 'seqTri3L') {
        return 6;
    } else if (dataName === 'seqTri4') {////
        return [trisL0, ['empty'],trisL0, ['tri3'], trisL1, ['tri3','tri4'],
            trisL2, ['tri3','tri4', 'tri5'],  trisL3, ['tri3','tri4', 'tri5', 'tri6'],
                trisL4, ['tri3','tri4', 'tri5', 'tri6', 'tri7'], trisL5, ['tri3','tri4', 'tri5', 'tri6', 'tri7', 'tri8'], trisL4, ['tri3','tri4', 'tri5', 'tri6', 'tri7'], trisL3, ['tri3','tri4', 'tri5', 'tri6'],  trisL2, ['tri3','tri4', 'tri5'], trisL1, ['tri3','tri4'], trisL0, ['tri3']];
    } else if (dataName === 'seqTri4L') {
        return 12;
    } else if (dataName === 'seqTri5') {////
        return [trisL0, ['empty'],trisL0, ['tri3'], trisL1, ['tri3','tri4'],
            trisL2, ['tri3','tri4', 'tri5'],  trisL3, ['tri3','tri4', 'tri5', 'tri6'],
            trisL4, ['tri3','tri4', 'tri5', 'tri6', 'tri7'], trisL5,
            ['tri3','tri4', 'tri5', 'tri6', 'tri7', 'tri8'],
            trisL4, ['tri4', 'tri5', 'tri6', 'tri7', 'tri8'],
            trisL3, ['tri5', 'tri6', 'tri7', 'tri8'],  trisL2,
            ['tri6', 'tri7', 'tri8'], trisL1, ['tri7', 'tri8'], trisL0, ['tri8']];
    } else if (dataName === 'seqTri5L') {
        return 12;
    } else if (dataName === 'seqTri6') {////
        return [trisL0, ['empty'],trisL0, ['tri8'], trisL1, ['tri7','tri8'],
            trisL2, ['tri6','tri7', 'tri8'],  trisL3, ['tri5','tri6', 'tri7', 'tri8'],
            trisL4, ['tri4','tri5', 'tri6', 'tri7', 'tri8'], trisL5,
            ['tri3','tri4', 'tri5', 'tri6', 'tri7', 'tri8'], trisL4,
            ['tri4', 'tri5', 'tri6', 'tri7', 'tri8'], trisL3,
            ['tri5', 'tri6', 'tri7', 'tri8'],  trisL2,
            ['tri6', 'tri7', 'tri8'], trisL1, ['tri7', 'tri8'],
                                    trisL0, ['tri8']];
    } else if (dataName === 'seqTri6L') {
        return 12;
    } else if (dataName === 'seqTri7') {////
        return [trisL0, ['empty'],trisL0, ['tri8'], trisL1, ['tri7','tri8'],
            trisL2, ['tri6','tri7', 'tri8'],  trisL3, ['tri5','tri6', 'tri7', 'tri8'],
            trisL4, ['tri4','tri5', 'tri6', 'tri7', 'tri8'], trisL5,
            ['tri3','tri4', 'tri5', 'tri6', 'tri7', 'tri8'], trisL4,
            ['tri3', 'tri4', 'tri5', 'tri6', 'tri7'], trisL3,
            ['tri3', 'tri4', 'tri5', 'tri6'],  trisL2,
            ['tri3', 'tri4', 'tri5'], trisL1, ['tri3', 'tri4'], trisL0, ['tri3']];
    } else if (dataName === 'seqTri7L') {
        return 12;
    } else if (dataName === 'seqTri20') {//'Pmm', 'P4mm'
        return [trisL0, ['empty'],trisL0, ['tri0'], trisL1, ['tri0','tri1'],
            trisL2, ['tri0','tri1', 'tri2'],  trisL3, ['tri0','tri1', 'tri2', 'tri3'],
            trisL4, ['tri0','tri1', 'tri2', 'tri3', 'tri4'], trisL5,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5'], trisL6,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6'],
            trisL7, ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
            trisL6, ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6'], trisL5,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5'], trisL4,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4'], trisL3,
            ['tri0','tri1', 'tri2', 'tri3'],  trisL2, ['tri0','tri1', 'tri2'],
            trisL1, ['tri0','tri1'], trisL0, ['tri0']];
    } else if (dataName === 'seqTri20L') {
        return 16;
    } else if (dataName === 'seqTri21') {
        return [trisL0, ['empty'],trisL0, ['tri0'], trisL1, ['tri0','tri1'],
            trisL2, ['tri0','tri1', 'tri2'],  trisL3, ['tri0','tri1', 'tri2', 'tri3'],
            trisL4, ['tri0','tri1', 'tri2', 'tri3', 'tri4'], trisL5,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5'], trisL6,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6'], trisL7,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
            trisL6, ['tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
            trisL5, ['tri2', 'tri3', 'tri4', 'tri5', 'tri6','tri7'], trisL4,
            ['tri3', 'tri4', 'tri5', 'tri6','tri7'], trisL3, ['tri4', 'tri5', 'tri6','tri7'],
            trisL2, ['tri5', 'tri6','tri7'], trisL1, ['tri6','tri7'], trisL0, ['tri7']];
    } else if (dataName === 'seqTri21L') {
        return 16;
    } else if (dataName === 'seqTri22') {//'Pmm'
        return [trisL0, ['empty'],trisL0, ['tri7'], trisL1, ['tri6','tri7'],
            trisL2, ['tri5','tri6', 'tri7'],  trisL3, ['tri4','tri5', 'tri6', 'tri7'],
            trisL4, ['tri3','tri4', 'tri5', 'tri6', 'tri7'], trisL5,
            ['tri2','tri3', 'tri4', 'tri5', 'tri6', 'tri7'], trisL6,
            ['tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'], trisL7,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
            trisL6, ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6'],
            trisL5, ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5'], trisL4,
            ['tri0','tri1', 'tri2', 'tri3', 'tri4'], trisL3,
            ['tri0','tri1', 'tri2', 'tri3'],  trisL2, ['tri0','tri1', 'tri2'],
            trisL1, ['tri0','tri1'], trisL0, ['tri0']];
    } else if (dataName === 'seqTri22L') {
        return 16;
    } else if (dataName === 'seqTri23') {
        return [trisL0, ['empty'],trisL0, ['tri7'], trisL1, ['tri6','tri7'],
        trisL2, ['tri5','tri6', 'tri7'],  trisL3, ['tri4','tri5', 'tri6', 'tri7'],
        trisL4, ['tri3','tri4', 'tri5', 'tri6', 'tri7'], trisL5,
        ['tri2','tri3', 'tri4', 'tri5', 'tri6', 'tri7'], trisL6,
        ['tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'], trisL7,
        ['tri0','tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
        trisL6, ['tri1', 'tri2', 'tri3', 'tri4', 'tri5', 'tri6', 'tri7'],
        trisL5, ['tri2', 'tri3', 'tri4', 'tri5', 'tri6','tri7'],
        trisL4, ['tri3', 'tri4', 'tri5', 'tri6','tri7'], trisL3,
        ['tri4', 'tri5', 'tri6','tri7'],  trisL2, ['tri5', 'tri6','tri7'],
        trisL1, ['tri6','tri7'], trisL0, ['tri7']];
    } else if (dataName === 'seqTri23L') {
        return 16;
    } 
}

function selectBasePoint(figureName, squareSt, pX, pPX, pY, pPY, qX, qPX, qY, qPY, rX, rPX, rY, rPY, sX, sPX, sY, sPY) {
    let pVX;
    let pVY;
    let qVX;
    let qVY;
    let rVX;
    let rVY;
    let sVX;
    let sVY;
    
    if ((figureName === 'floppingTriangle1') && squareSt === false ) {
        pVX = pPX;
        pVY = pPY;
        qVX = qPX;
        qVY = qPY;
        rVX = rPX;
        rVY = rPY;
        return [pVX, pVY, qVX, qVY, rVX, rVY];
    } else if ((figureName === 'floppingTriangle1' ) && squareSt === true ) {
        pVX = pPX;
        pVY = pPY;
        qVX = qPX;
        qVY = qPY;
        rVX = rPX;
        rVY = rPY;
        sVX = sPX;
        sVY = sPY;
        return [pVX, pVY, qVX, qVY, rVX, rVY, sVX, sVY];
    } else if (squareSt === false) {
        pVX = pX;
        pVY = pY;
        qVX = qX;
        qVY = qY;
        rVX = rX;
        rVY = rY;
        return [pVX, pVY, qVX, qVY, rVX, rVY];
    } else if (squareSt === true ) {
        pVX = pX;
        pVY = pY;
        qVX = qX;
        qVY = qY;
        rVX = rX;
        rVY = rY;
        sVX = sX;
        sVY = sY;
        return [pVX, pVY, qVX, qVY, rVX, rVY, sVX, sVY];
    }
}

function trajectoryBB(stopSt, varRad, groupName, figureName, num, mX, mY, vX, vY) {
    let varSmall = groupData(groupName, figureName, 'varSmall');
    let xX;
    let xY;
    let uX;
    let uY;
    let squareState = groupData(groupName, figureName, 'squareFlag');
    let pX = groupData(groupName, figureName, 'pX');
    let pY = groupData(groupName, figureName, 'pY');
    let qX = groupData(groupName, figureName, 'qX');
    let qY = groupData(groupName, figureName, 'qY');
    let rX = groupData(groupName, figureName, 'rX');
    let rY = groupData(groupName, figureName, 'rY');
    let pqNX = groupData(groupName, figureName, 'pqNX');//2024/09/18
    let pqNY = groupData(groupName, figureName, 'pqNY');//2024/09/18
    let qrNX = groupData(groupName, figureName, 'qrNX');//2024/09/18
    let qrNY = groupData(groupName, figureName, 'qrNY');//2024/09/18

    let sX;
    let sY;
    let rpNX;
    let rpNY;
    let rsNX;
    let rsNY;
    let spNX;
    let spNY;
    let mpqD = orientedD(mX, mY, pX, pY, qX, qY);
    let mqrD = orientedD(mX, mY, qX, qY, rX, rY);
    let mrsD;
    let mspD;
    let mrpD;
    if (squareState == true) {
        sX = groupData(groupName, figureName, 'sX');
        sY = groupData(groupName, figureName, 'sY');
        rsNX = groupData(groupName, figureName, 'rsNX');
        rsNY = groupData(groupName, figureName, 'rsNY');
        spNX = groupData(groupName, figureName, 'spNX');
        spNY = groupData(groupName, figureName, 'spNY');
        mrsD = orientedD(mX, mY, rX, rY, sX, sY);
        mspD = orientedD(mX, mY, sX, sY, pX, pY);
    } else {
        rpNX = groupData(groupName, figureName, 'rpNX');
        rpNY = groupData(groupName, figureName, 'rpNY');
        mrpD = orientedD(mX, mY, rX, rY, pX, pY);
    }

    if (squareState === true) {
        if (mpqD > varRad && mqrD > varRad && mrsD > varRad && mspD > varRad) {
            uX = vX;
            uY = vY;
        } else if ((mspD <= varRad && mpqD <= varRad) || (mpqD <= varRad && mqrD === varRad) || (mqrD === varRad && mrsD === varRad) || (mrsD === varRad && mspD === varRad)) {//exceptional handling at s
            uX = -vX;
            uY = -vY;
        } else if (mpqD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * pqNX + vY * pqNY) * pqNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (uX * pqNX + vY * pqNY) * pqNY;//2024/09/18
        } else if (mqrD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * qrNX + vY * qrNY) * qrNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * qrNX + vY * qrNY) * qrNY;//2024/09/18
        } else if (mrsD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * rsNX + vY * rsNY) * rsNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * rsNX + vY * rsNY) * rsNY;//2024/09/18
        } else if (mspD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * spNX + vY * spNY) * spNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * spNX + vY * spNY) * spNY;//2024/09/18
        }
    } else {
        if (mpqD > varRad && mqrD > varRad && mrpD > varRad) {
            uX = vX;
            uY = vY;
        } else if ((mrpD <= varRad && mpqD <= varRad) || (mpqD <= varRad && mqrD <= varRad) || (mqrD <= varRad && mrpD <= varRad)) {//2024/11/19
            uX = -vX;
            uY = -vY;
        } else if (mpqD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * pqNX + vY * pqNY) * pqNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * pqNX + vY * pqNY) * pqNY;//2024/09/18
        } else if (mqrD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * qrNX + vY * qrNY) * qrNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * qrNX + vY * qrNY) * qrNY;//2024/09/18
        } else if (mrpD <= varRad) {
            uX = vX - 2 * (1 + varSmall) * (vX * rpNX + vY * rpNY) * rpNX;//2024/09/18
            uY = vY - 2 * (1 + varSmall) * (vX * rpNX + vY * rpNY) * rpNY;//2024/09/18
        }
    }

    if (stopSt === 'ongoing') {
        xX = mX + varSpeed * uX;
        xY = mY + varSpeed * uY;
        //n++;//update n
    } else {
        xX = mX;
        xY = mY;
        //n = n;//stop n
    }
    return [xX, xY, uX, uY];
}

function trajectoryBB2(stopSt, varRad, groupName, figureName, num, mX, mY, vX, vY, mPX, mPY, vPX, vPY) {
    let varSmall = groupData(groupName, figureName, 'varSmall');
    let varSmall2 = groupData(groupName, figureName, 'varSmall2');
    let distB = dist(mX, mY, mPX, mPY);
    let xX;
    let xY;
    let xPX;
    let xPY;
    let uX;
    let uY;
    let uPX;
    let uPY;
    let eX;
    let eY;
    let inProd;
    let modInpro;

    if (distB > 2 * varRad) {
        [xX, xY, uX, uY] = trajectoryBB(stopSt, varRad, groupName, figureName,num, mX, mY, vX, vY);
        [xPX, xPY, uPX, uPY] = trajectoryBB(stopSt, varRad, groupName, figureName, num, mPX, mPY, vPX, vPY);
    } else {
        eX = (mX - mPX) / (2 * varRad);
        eY = (mY - mPY) / (2 * varRad);
        inProd = (vX - vPX) * eX + (vY - vPY) * eY;//magnitude correction
        modInpro = (1 + varSmall) * inProd;
        if (inProd >= -varSmall2) { //correction of forces
            uX = vX + varSmall2 * eX;//eX = (mX - mPX) /(*)
            uY = vY + varSmall2 * eY;
            uPX = vPX - varSmall2 * eX;
            uPY = vPY - varSmall2 * eY;
        } else {
            uX = vX - modInpro * eX;
            uY = vY - modInpro * eY;
            uPX = vPX + modInpro * eX;
            uPY = vPY + modInpro * eY;
        }
    }

    if (stopSt === 'ongoing') {
        xX = mX + varSpeed * uX;
        xY = mY + varSpeed * uY;
        xPX = mPX + varSpeed * uPX;
        xPY = mPY + varSpeed * uPY;
        //correct directions
        distB = dist(xX, xY, xPX, xPY);
        if (distB <= varRad) {
            uX = uX - varSmall * eY;
            uY = uY + varSmall * eX;
            uPX = uPX + varSmall * eY;
            uPY = uPY - varSmall * eX;
        }
        xX = mX + varSpeed * uX;
        xY = mY + varSpeed * uY;
        xPX = mPX + varSpeed * uPX;
        xPY = mPY + varSpeed * uPY;
        n++;
    } else {
        xX = mX;
        xY = mY;
        xPX = mPX;
        xPY = mPY;
        n = n;
    }
    return [xX, xY, uX, uY, xPX, xPY, uPX, uPY];
}

function writeBall(mX, mY, diam) {
    push();
        circle(mX, mY, diam);
    pop();
}

function generatLattice(lineSt, groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7, data8) {
    //function generating whole lattice 
    push();
        let I = groupData(groupName, figureName, 'firstDelimiter');
        let J = groupData(groupName, figureName, 'secondDelimiter');
        let v1X = groupData(groupName, figureName, 'basicVector0X');
        let v1Y = groupData(groupName, figureName, 'basicVector0Y');
        let v2X = groupData(groupName, figureName, 'basicVector1X');
        let v2Y = groupData(groupName, figureName, 'basicVector1Y');
        translate(- (I - 1) * v1X - (J - 1) * v2X, - (I - 1) * v1Y - (J - 1) * v2Y);
        for (let i = -(I - 1); i < I; i++) {
            for (let j = -(J - 1); j < J; j++) {
                dirichleDomain(lineSt, groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7, data8);
                translate(v2X, v2Y);
            }
            translate(- (2 * J - 1) * v2X + v1X, - (2 * J - 1) * v2Y + v1Y);// =-(2*J-1)(v2X,v2Y) + (v1X,v1Y)
        }
    pop();
}

function fundDomRot(lineSt, groupName, figureName, num, data0, data1, data2, data3,data4, data5, data6, data7, data8) {
    //function generate mirror and the fundamental domain of point groop
    push();
        let mX = data0;
        let mY = data1;
        let mPX = data2;
        let mPY = data3;
        let pX = groupData(groupName, figureName, 'pX'); // outer triangle or rectangle
        let pY = groupData(groupName, figureName, 'pY');
        let qX = groupData(groupName, figureName, 'qX');
        let qY = groupData(groupName, figureName, 'qY');
        let rX = groupData(groupName, figureName, 'rX');
        let rY = groupData(groupName, figureName, 'rY');
        let pPX = groupData(groupName, figureName, 'pPX'); // still triangle or large traingle
        let pPY = groupData(groupName, figureName, 'pPY');
        let qPX = groupData(groupName, figureName, 'qPX');
        let qPY = groupData(groupName, figureName, 'qPY');
        let rPX = groupData(groupName, figureName, 'rPX');
        let rPY = groupData(groupName, figureName, 'rPY');
        let radB1 = groupData(groupName, figureName, 'radB1');
        let radB2 = groupData(groupName, figureName, 'radB2');
        let diamB1 = 2 * radB1;
        let diamB2 = 2 * radB2;
        let squareState = groupData(groupName, figureName, 'squareFlag');
        //data of tri0 
        let p0X;
        let p0Y;
        let q0X;
        let q0Y;
        let r0X;
        let r0Y;
        //data of tri1 
        let p1X;
        let p1Y;
        let q1X;
        let q1Y;
        let r1X;
        let r1Y;
        //data of tri2 
        let p2X;
        let p2Y;
        let q2X;
        let q2Y;
        let r2X;
        let r2Y;
        //data of tri3 
        let p3X;
        let p3Y;
        let q3X;
        let q3Y;
        let r3X;
        let r3Y;
        //data of tri4 
        let p4X;
        let p4Y;
        let q4X;
        let q4Y;
        let r4X;
        let r4Y;
        //data of tri5 
        let p5X;
        let p5Y;
        let q5X;
        let q5Y;
        let r5X;
        let r5Y;
        //data of tri6 
        let p6X;
        let p6Y;
        let q6X;
        let q6Y;
        let r6X;
        let r6Y;
        //data of tri7 
        let p7X;
        let p7Y;
        let q7X;
        let q7Y;
        let r7X;
        let r7Y;
        //data of tri8 
        let p8X;
        let p8Y;
        let q8X;
        let q8Y;
        let r8X;
        let r8Y;
        [p0X, p0Y, q0X, q0Y, r0X, r0Y] = groupData(groupName, figureName, 'tri0');
        [p1X, p1Y, q1X, q1Y, r1X, r1Y] = groupData(groupName, figureName, 'tri1');
        [p2X, p2Y, q2X, q2Y, r2X, r2Y] = groupData(groupName, figureName, 'tri2');
        [p3X, p3Y, q3X, q3Y, r3X, r3Y] = groupData(groupName, figureName, 'tri3');
        [p4X, p4Y, q4X, q4Y, r4X, r4Y] = groupData(groupName, figureName, 'tri4');
        [p5X, p5Y, q5X, q5Y, r5X, r5Y] = groupData(groupName, figureName, 'tri5');
        [p6X, p6Y, q6X, q6Y, r6X, r6Y] = groupData(groupName, figureName, 'tri6');
        [p7X, p7Y, q7X, q7Y, r7X, r7Y] = groupData(groupName, figureName, 'tri7');
        [p8X, p8Y, q8X, q8Y, r8X, r8Y] = groupData(groupName, figureName, 'tri8');

        let sX;
        let sY;
        if (squareState == true) {
            sX = groupData(groupName, figureName, 'sX');
            sY = groupData(groupName, figureName, 'sY');
        }

        if (lineSt === 'lineOn') {
            if (squareState === true) {
                quad(pX, pY, qX, qY, rX, rY, sX, sY);
                quad(pX, pY, qX, qY, rX, -rY, sX, -sY);
            } else {
                triangle(pX, pY, qX, qY, rX, rY);
                triangle(pX, pY, qX, qY, rX, -rY);
            }
        }

        if (groupData(groupName, figureName, 'mirState') === true) {
            if (figureName === 'bounceBall') {
                fill(FRONT_COLOR_0);
                writeBall(mX, mY, diamB1);
                writeBall(mX, -mY, diamB1);
            } else if (figureName === 'bounceBall1') {
                fill(FRONT_COLOR_0);
                writeBall(mX, mY, diamB2);
                writeBall(mX, -mY, diamB2);
                fill(FRONT_COLOR_8);
                writeBall(mPX, mPY, diamB2);
                writeBall(mPX, -mPY, diamB2);
            } else if (figureName === 'stillTriangle') {
                fill(FRONT_COLOR_0);
                triangle(pPX, pPY, qPX, qPY, rPX, rPY);
                triangle(pPX, -pPY, qPX, -qPY, rPX, -rPY);
            } else if (figureName === 'floppingTriangle') {
                writTriS(groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7,data8);
            } else if (figureName === 'floppingTriangle1') {
                writTriS(groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7,data8);
            }
        }
        fill(BACK_COLOR);
    pop();
}

function dirichleDomain(lineSt, groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7, data8) {
    // function generating the fundmental domain of lattice
    push();
        let I = groupData(groupName, figureName, 'denomiNator');
        for (let i = 0; i < I; i++) {
            fundDomRot(lineSt, groupName, figureName, num, data0, data1, data2, data3, data4, data5, data6, data7, data8);
            rotate(2 * PI / I);
        }
    pop();
}

function orientedD(xX, xY, pX, pY, qX, qY) {
    return ((xY - pY) * (qX - pX) - (xX - pX) * (qY - pY)) / dist(pX, pY, qX, qY);
}

function writTriS(groupName, figureName, numTris, triName0, triName1, triName2, triName3, triName4, triName5, triName6, triName7, triName8){
    push();
        if ( numTris === 1 ){
            writTri(groupName, figureName, triName0);
        } else if ( numTris === 2 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
        } else if ( numTris === 3 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
        } else if ( numTris === 4 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
        } else if ( numTris === 5 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
            writTri(groupName, figureName, triName4);
        } else if ( numTris === 6 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
            writTri(groupName, figureName, triName4);
            writTri(groupName, figureName, triName5);
        }else if ( numTris === 7 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
            writTri(groupName, figureName, triName4);
            writTri(groupName, figureName, triName5);
            writTri(groupName, figureName, triName6);       
        } else if ( numTris === 8 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
            writTri(groupName, figureName, triName4);
            writTri(groupName, figureName, triName5);
            writTri(groupName, figureName, triName6);       
            writTri(groupName, figureName, triName7);       
        }else if ( numTris === 9 ){
            writTri(groupName, figureName, triName0);
            writTri(groupName, figureName, triName1);
            writTri(groupName, figureName, triName2);
            writTri(groupName, figureName, triName3);
            writTri(groupName, figureName, triName4);
            writTri(groupName, figureName, triName5);
            writTri(groupName, figureName, triName6);       
            writTri(groupName, figureName, triName7);
            writTri(groupName, figureName, triName8); 
        }
        //console.log(triName7);
    pop();
}

function writTri(groupName, figureName, triName){
    push();
        //data of tri0 
        let p0X;
        let p0Y;
        let q0X;
        let q0Y;
        let r0X;
        let r0Y;
        //data of tri1 
        let p1X;
        let p1Y;
        let q1X;
        let q1Y;
        let r1X;
        let r1Y;
        //data of tri2 
        let p2X;
        let p2Y;
        let q2X;
        let q2Y;
        let r2X;
        let r2Y;
        //data of tri3 
        let p3X;
        let p3Y;
        let q3X;
        let q3Y;
        let r3X;
        let r3Y;
        //data of tri4 
        let p4X;
        let p4Y;
        let q4X;
        let q4Y;
        let r4X;
        let r4Y;
        //data of tri5 
        let p5X;
        let p5Y;
        let q5X;
        let q5Y;
        let r5X;
        let r5Y;
        //data of tri6 
        let p6X;
        let p6Y;
        let q6X;
        let q6Y;
        let r6X;
        let r6Y;
        //data of tri7 
        let p7X;
        let p7Y;
        let q7X;
        let q7Y;
        let r7X;
        let r7Y;
        //data of tri8 
        let p8X;
        let p8Y;
        let q8X;
        let q8Y;
        let r8X;
        let r8Y;
        [p0X, p0Y, q0X, q0Y, r0X, r0Y] = groupData(groupName, figureName, 'tri0');
        [p1X, p1Y, q1X, q1Y, r1X, r1Y] = groupData(groupName, figureName, 'tri1');
        [p2X, p2Y, q2X, q2Y, r2X, r2Y] = groupData(groupName, figureName, 'tri2');
        [p3X, p3Y, q3X, q3Y, r3X, r3Y] = groupData(groupName, figureName, 'tri3');
        [p4X, p4Y, q4X, q4Y, r4X, r4Y] = groupData(groupName, figureName, 'tri4');
        [p5X, p5Y, q5X, q5Y, r5X, r5Y] = groupData(groupName, figureName, 'tri5');
        [p6X, p6Y, q6X, q6Y, r6X, r6Y] = groupData(groupName, figureName, 'tri6');
        [p7X, p7Y, q7X, q7Y, r7X, r7Y] = groupData(groupName, figureName, 'tri7');
        [p8X, p8Y, q8X, q8Y, r8X, r8Y] = groupData(groupName, figureName, 'tri8');

        if (triName === 'tri0'){
            fill(colorV0);
            triangle(p0X, p0Y, q0X, q0Y, r0X, r0Y);
            triangle(p0X, -p0Y, q0X, -q0Y, r0X, -r0Y);
        }
        if (triName === 'tri1'){
            fill(colorV1);
            triangle(p1X, p1Y, q1X, q1Y, r1X, r1Y);
            triangle(p1X, -p1Y, q1X, -q1Y, r1X, -r1Y);
        }
        if (triName === 'tri2'){
            fill(colorV2);
            triangle(p2X, p2Y, q2X, q2Y, r2X, r2Y);
            triangle(p2X, -p2Y, q2X, -q2Y, r2X, -r2Y);
        }
        if (triName === 'tri3'){
            fill(colorV3);
            triangle(p3X, p3Y, q3X, q3Y, r3X, r3Y);
            triangle(p3X, -p3Y, q3X, -q3Y, r3X, -r3Y);
        }
        if (triName === 'tri4'){
            fill(colorV4);
            triangle(p4X, p4Y, q4X, q4Y, r4X, r4Y);
            triangle(p4X, -p4Y, q4X, -q4Y, r4X, -r4Y);
        }
        if (triName === 'tri5'){
            fill(colorV5);
            triangle(p5X, p5Y, q5X, q5Y, r5X, r5Y);
            triangle(p5X, -p5Y, q5X, -q5Y, r5X, -r5Y);
        }
        if (triName === 'tri6'){
            fill(colorV6);
            triangle(p6X, p6Y, q6X, q6Y, r6X, r6Y);
            triangle(p6X, -p6Y, q6X, -q6Y, r6X, -r6Y);
        }
        if (triName === 'tri7'){
            fill(colorV7);
            triangle(p7X, p7Y, q7X, q7Y, r7X, r7Y);
            triangle(p7X, -p7Y, q7X, -q7Y, r7X, -r7Y);
        } if (triName === 'tri8'){
            fill(colorV8);
            triangle(p8X, p8Y, q8X, q8Y, r8X, r8Y);
            triangle(p8X, -p8Y, q8X, -q8Y, r8X, -r8Y);
        }  
        if (triName === 'empty'){
            ;
        }
    pop();
}

function colorSet (groupName){
    let colorScheme = random(['colorSet0', 'colorSet1']); 
    let colorVI0 = FRONT_COLOR_0;
    let colorVI1 = FRONT_COLOR_1;
    let colorVI2 = FRONT_COLOR_2;
    let colorVI3 = FRONT_COLOR_3;
    let colorVI4 = FRONT_COLOR_4;
    let colorVI5 = FRONT_COLOR_5;
    let colorVI6 = FRONT_COLOR_6;
    let colorVI7 = FRONT_COLOR_7;
    let colorVI8 = FRONT_COLOR_8;
    if (colorScheme === 'colorSet0'){
        colorVI0 = FRONT_COLOR_0;
        colorVI1 = FRONT_COLOR_1;
        colorVI2 = FRONT_COLOR_2;
        colorVI3 = FRONT_COLOR_3;
        colorVI4 = FRONT_COLOR_4;
        colorVI5 = FRONT_COLOR_5;
        colorVI6 = FRONT_COLOR_6;
        colorVI7 = FRONT_COLOR_7;
        colorVI8 = FRONT_COLOR_8;
        if (groupName === 'P3mm'){
            colorVI3 = FRONT_COLOR_0;
            colorVI4 = FRONT_COLOR_1;
            colorVI5 = FRONT_COLOR_2;
            colorVI6 = FRONT_COLOR_5;
            colorVI7 = FRONT_COLOR_6;
            colorVI8 = FRONT_COLOR_7
        } else if (groupName === 'P6mm'){
            colorVI0 = FRONT_COLOR_0;
            colorVI1 = FRONT_COLOR_3;
            colorVI2 = FRONT_COLOR_7;
        }
    } else if (colorScheme === 'colorSet1' ){
        colorVI0 = FRONT_COLOR_0;
        colorVI1 = FRONT_COLOR_0;
        colorVI2 = FRONT_COLOR_0;
        colorVI3 = FRONT_COLOR_0;
        colorVI4 = FRONT_COLOR_0;
        colorVI5 = FRONT_COLOR_0;
        colorVI6 = FRONT_COLOR_0;
        colorVI7 = FRONT_COLOR_0;
        colorVI8 = FRONT_COLOR_0;
    } 
    
    return [colorVI0, colorVI1, colorVI2, colorVI3, colorVI4, colorVI5, colorVI6, colorVI7, colorVI8];
}

function resetBackground() {
    background(BACK_COLOR);
    groupState = selectGroup.value();//we need this definition here.
    figureState = selectFigure.value();
    varScale = setScale.value();
    varSegment = BASE_SEGMENT * varScale;
    varHeight = sqrt(3) * varSegment / 2;
    varSpeed = SPEED * varScale;
    varRadius = RADIUS1 * varScale;
    if (groupState === 'auto') {
        presentGroup = random(GROUP_LIST); //presentGroup is a global varialble
    } else {
        presentGroup = groupState;
    }
    if (figureState === 'auto') {
        presentFigure = random(FIGURE_LIST); //presentGroup is a global varialble
    } else {
        presentFigure = figureState;
    }
    [colorV0, colorV1, colorV2, colorV3, colorV4, colorV5, colorV6, colorV7, colorV8] = colorSet(presentGroup);

    angleB = random(0, 2 * PI);
    angleBP = random(0, 2 * PI);
    uX = cos(angleB);
    uY = sin(angleB);
    uPX = cos(angleBP);
    uPY = sin(angleBP);
    xX = groupData(presentGroup, presentFigure, 'x0X');
    xY = groupData(presentGroup, presentFigure, 'x0Y');
    xPX = groupData(presentGroup, presentFigure, 'xP0X');
    xPY = groupData(presentGroup, presentFigure, 'xP0Y');
    n = 0;
    m = 0;
    k = 0;
}